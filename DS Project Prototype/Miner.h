#pragma once

#include <queue>
#include <functional>
#include <optional>
#include <thread>
#include <mutex>
#include <fstream>
#include "Message.h"
#include "nlohmann.h"
#include <iostream>

namespace Blockchain
{
	class MessageHandlerMap;
	// these are the functions that are called in response to a message
	// they may or may not return blocks, hence theuse of std::optional
	typedef std::function<std::optional<class Block>(size_t, const MsgPtr)> Callable;

	// miners can be configured to react a certain way to specific mesage types
	// using the MessageHandlerMap class
	// the one requirement for the Map's configuration is that it must return a 
	// an empty optional to indicate termination
	class Miner
	{
		enum class State
		{
			Running,
			Waiting,
			Terminated,
		};
	public:
		// no default constructors
		Miner(size_t PID, const std::queue<MsgPtr>& incoming_messages, std::mutex& mtx, std::mutex& wMtx,
			std::function<void(const MsgPtr)> sendMessage, const MessageHandlerMap& msgHandler);
		// joins the processes and waits for it to exit
		~Miner();
		size_t GetPID() const;

		// check the miner's current state
		bool Waiting() const;
		bool Terminated() const;
		bool Running() const;
		// save a pased json object
		void SaveBlock(const nlohmann::json& j);
		// get data from the process in json form based on a given predicate
		template <typename Pred>
		nlohmann::json GetBlocks(Pred p)
		{
			nlohmann::json arr = nlohmann::json::array();
			std::ifstream in(filename);

			try
			{
				while (in.peek() != EOF)
				{
					nlohmann::json obj;
					in >> obj;
					if (!obj.is_null() && p(obj))
						arr.push_back(obj);
				}
			}
			catch (const std::exception& e)
			{
				std::cerr << PID << ": " << e.what() << std::endl;
			}

			return arr;
		}

	private:
		// gets called once when a new thread starts execution
		void func();
	private:
		std::string filename;

		State s = State::Waiting;
		// thread id
		const size_t PID;
		// everything used by the thread
		// used when calling the message handler
		std::mutex& mtx;
		// used for getting the appropriate function to handle a message
		const MessageHandlerMap& msgHandler;
		// used when calling send messages
		std::mutex& wMtx;
		// used to send messages outside of the thread
		std::function<void(const MsgPtr)> sendMessage;
		// contains messages from the outside (also potentially from othr processes)
		const std::queue<MsgPtr>& incoming_messages;
		// the actual process/miner
		std::thread t;
	};

	// the solution generated by a miner in response to a puzzle
	class Solution : public Message
	{
	public:
		Solution(size_t senderID, const Block& mined_block)
			:
			Message(senderID),
			b(mined_block)
		{}
		// get the mined block
		Block GetBlock() const
		{
			return b;
		}
		virtual std::type_index GetTypeID() const override
		{
			return typeid(Solution);
		}

	private:
		Block b;
	};
}

